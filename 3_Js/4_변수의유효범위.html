<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>변수의 유효범위</h1>
    <input type="button" value="전역 | 지역" onclick="test1();">
    <input type="button" value="scope" onclick="test2();">
    <input type="button" value="개선" onclick="test3();">

    <script>
        var a; //전역변수(window 객체의 속성으로 등)
        a=100;
        
        let a2;//es6에 등장한 변수 
        const a3 =1;//상수값 저장시. 전역변수 (es6에 등장)

        function test1(){
            var a = "아"; //지역변수
             console.log(a);//아
             console.log(this.a);//100 
             //this는== window
             console.log(window.a);//100
             //알반함수에서 this는 window를 가리킴

             //var변수의 단점
             var a=true;//변수 중복선언 가능.. 에러가 안뜸
             b = 123;//var 없이 변수 선언이 가능. 단, 항상 전역변수(window)로 등록 
             console.log(window.b);
        }
        /*
        scope :  유효범유ㅣ
        java의 변수 scope는 block scope
        javascropt의 변수(var) scope는 fuction scope를 가지고 잇다. 
        */
       function test2(){
        var x=10; 
        if(true){
            var x2=10;
        }
          console.log(x);//10
          console.log(x2);

          for(var i=0; i<10; i++){

          }
          console.log("i",i);
       }//자바랑 다르게 중괄호 밖에서도 출력이 가능한 한번 선언한 뱐수를 

     
    </script>

    <script>
        console.log(a)
    </script>

<h1>Hoisting</h1>
<script>
    //var b;//var키워드 변수는 자동hoiting 된다.
    //fuctio fo()E또한 자동 hoisting 된다. 
    console.log(b);//undefined
    var b= "안녕";

    //함수도 hoisting된다. 
    
    function foo(){
        console.log("foo");
    }
    foo();

//함수 표현식ㄷ으로느 생성한 함수는 호이스팅되지 않는다.
//bat(); 함수표현식으로 작성한 함수는 호이스팅불가 
var bar= function(){
    console.log('bar');
};
bar();
</script>
</body>
</html>